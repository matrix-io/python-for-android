from os.path import join, isdir, isfile
import sh
from pythonforandroid.recipe import NDKRecipe, CythonRecipe, Recipe
from pythonforandroid.toolchain import current_directory, shprint
from pythonforandroid.logger import info
from multiprocessing import cpu_count
import glob

"""
p4a apk --sdk-dir /opt/android/android-sdk --ndk-dir /opt/android/android-ndk --android_api 27 --private . --ignore-setup-py --package=com.admobilize.admp --name "ADMProvider" --version 1.2.10 --bootstrap=sdl2  --requirements=hostpython3,python3,kivy,docopt,libzmq,pyzmq,matrix-io-malos,matrix-io-proto,googleapis-common-protos,admobilizeapis,hbmqtt,pyyaml,pyjwt,pytz,six,librt,grpc,setuptools,protobuf_cpp,cryptography,pillow==6.0.0,pyopenssl,websockets,transitions,docopt,aiosqlite --permission INTERNET
"""


class GRPCRecipe(CythonRecipe):
    name = "grpc"
    version = "v1.20.1"
    # url = 'https://github.com/grpc/grpc/archive/{version}.zip'
    url = None
    port_git = "https://github.com/grpc/grpc.git"
    generated_libraries = [
        "libgrpc++_cronet.so",
        "libgrpc_csharp_ext.so",
        "libgrpc++_unsecure.so",
        "libgrpc_plugin_support.so",
        "libgrpc++.so",
        "libgrpc_cronet.so",
        "libgrpc_unsecure.so",
        "libgrpc.so",
        "libaddress_sorting.a",
        "libbenchmark.a",
        "libbenchmark_main.a",
        "libcares.so",
        "libcrypto.a",
        "libgflags.a",
        "libgflags_nothreads.a",
        "libglog.a",
        "libgpr.a",
        "libgrpc.a",
        "libgrpc++.a",
        "libgrpc_cronet.a",
        "libgrpc++_cronet.a",
        "libgrpc_csharp_ext.so",
        "libgrpc_plugin_support.a",
        "libgrpc_unsecure.a",
        "libgrpc++_unsecure.a",
        "libprotobuf.a",
        "libprotobuf-lite.a",
        "libprotoc.a",
        "libssl.a",
        "libz.a",
        "libz.so",
    ]
    site_packages_name = "grpcio"
    depends = ["setuptools"]
    cython_args = ["src/python/grpcio/grpc/_cython"]

    def get_lib_dir(self, arch):
        return join(self.get_build_dir(arch.arch), "build", "lib", arch.arch)

    def get_recipe_env(self, arch):
        env = super(GRPCRecipe, self).get_recipe_env(arch)
        env["CC"] = "arm-linux-androideabi-gcc "
        env["ANDROID_NDK"] = self.ctx.ndk_dir
        env["ANDROID_SDK"] = self.ctx.sdk_dir
        env[
            "GRPC_PYTHON_CFLAGS"
        ] = " -DANDROID -fpermissive -I/home/user/.local/share/python-for-android/build/other_builds/grpc-python3/armeabi-v7a__ndk_target_21/grpc/grpc/third_party/boringssl/include/ -I/opt/android/android-ndk/sources/cxx-stl/gnu-libstdc++/4.9/include -I/opt/android/android-ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include -std=c++11 -std=c99 -fvisibility=hidden -fno-wrapv -fno-exceptions -w -fno-rtti"
        # env["GRPC_PYTHON_BUILDER_SYSTEM_CARES"] = "yes"
        env[
            "GRPC_PYTHON_LDFLAGS"
        ] = " -L/opt/android/android-ndk/sysroot/usr/lib/arm-linux-androideabi/lib -Wl,-wrap,memcpy -static-libgcc -static-libstdc++ -llog -ldl -lm"
        return env

    def prebuild_arch(self, arch):
        build_dir = self.get_build_dir(arch.arch)
        source_dir = join(build_dir, "grpc")
        if not isfile(join(source_dir, "setup.py")):
            info("clone GRPC sources from {}".format(self.port_git))
            shprint(
                sh.git,
                "clone",
                "--branch",
                self.version,
                "--recursive",
                self.port_git,
                source_dir,
                _tail=20,
                _critical=True,
            )

    def build_arch(self, arch):
        Recipe.build_arch(self, arch)
        build_dir = self.get_build_dir(arch.arch)
        source_dir = join(build_dir, "grpc")
        build_dir = join(source_dir, "build")
        if not isdir(build_dir):
            shprint(sh.rm, "-rf", build_dir)
            shprint(sh.mkdir, "-p", build_dir)
            with current_directory(build_dir):
                env = self.get_recipe_env(arch)

                python_major = self.ctx.python_recipe.version[0]
                python_include_root = self.ctx.python_recipe.include_root(arch.arch)
                python_site_packages = self.ctx.get_site_packages_dir()
                python_link_root = self.ctx.python_recipe.link_root(arch.arch)
                python_link_version = self.ctx.python_recipe.major_minor_version_string
                if "python3" in self.ctx.python_recipe.name:
                    python_link_version += "m"
                python_library = join(
                    python_link_root, "libpython{}.so".format(python_link_version)
                )
                python_include_numpy = join(
                    python_site_packages, "numpy", "core", "include"
                )

                shprint(
                    sh.cmake,
                    "-DP4A=ON",
                    "-DANDROID_ABI={}".format(arch.arch),
                    "-DANDROID_STANDALONE_TOOLCHAIN={}".format(self.ctx.ndk_dir),
                    "-DANDROID_NATIVE_API_LEVEL={}".format(self.ctx.ndk_api),
                    "-DANDROID_EXECUTABLE={}/tools/android".format(env["ANDROID_SDK"]),
                    "-DCMAKE_TOOLCHAIN_FILE={}".format(
                        join(
                            self.ctx.ndk_dir,
                            "build",
                            "cmake",
                            "android.toolchain.cmake",
                        )
                    ),
                    "-DBUILD_WITH_STANDALONE_TOOLCHAIN=ON",
                    "-DBUILD_SHARED_LIBS=ON",
                    "-DBUILD_STATIC_LIBS=OFF",
                    "-Dprotobuf_BUILD_PROTOC_BINARIES=OFF",
                    '-DCMAKE_INSTALL_PREFIX="/opt/install"',
                    '-DCMAKE_FIND_ROOT_PATH="/opt/install"',
                    "-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=BOTH",
                    '-DCMAKE_SHARED_LINKER_FLAGS="-llog"',
                    '-DCMAKE_EXE_LINKER_FLAGS="-llog"',
                    "-DProtobuf_PROTOC_EXECUTABLE=/usr/local/bin/protoc",
                    "-DProtobuf_LIBRARIES=/opt/install/lib/libprotobuf.a",
                    "-DProtobuf_PROTOC_LIBRARY=/opt/install/lib/libprotoc.a",
                    "-DProtobuf_INCLUDE_DIR=/opt/install/include",
                    "-DHAVE_THREAD_SAFETY_ATTRIBUTES=ON",
                    "-DHAVE_GNU_POSIX_REGEX=ON",
                    "-DHAVE_STD_REGEX=ON",
                    "-DRUN_HAVE_STD_REGEX=ON",
                    "-DHAVE_POSIX_REGEX=1",
                    "-DRUN_HAVE_POSIX_REGEX=ON",
                    "-DHAVE_STEADY_CLOCK=ON",
                    "-DgRPC_BUILD_TESTS=OFF",
                    "-DCMAKE_CROSSCOMPILING=1",
                    "-DOPENSSL_SSL_LIBRARY=/usr/local/lib/libssl.so",
                    "-DOPENSSL_CRYPTO_LIBRARY=/usr/local/lib/libcrypto.so",
                    "-DOPENSSL_INCLUDE_DIR=/usr/local/include",
                    "-Dgflags_DIR=/opt/install/lib/cmake/gflags",
                    "-DgRPC_PROTOBUF_PROVIDER=package",
                    "-DgRPC_ZLIB_PROVIDER=package",
                    "-DgRPC_CARES_PROVIDER=package",
                    "-DgRPC_SSL_PROVIDER=package",
                    "-DgRPC_GFLAGS_PROVIDER=package",
                    "-DgRPC_BUILD_CODEGEN=OFF",
                    source_dir,
                    _env=env,
                )
                shprint(sh.make, "-j" + str(cpu_count()))
                # Copy third party shared libs that we need in our final apk
                # sh.cp('-a', sh.glob('./lib/{}/lib*.a'.format(arch.arch)),
                #      self.ctx.get_libs_dir(arch.arch))

                # copy static libs to libs collection
                for lib in sh.glob(join(build_dir, "*.a")):
                    shprint(sh.cp, "-L", lib, self.ctx.libs_dir)

                for lib in sh.glob(join(build_dir, "*.so")):
                    shprint(sh.cp, "-L", lib, self.ctx.libs_dir)

        self.build_cython_components(arch)
        self.install_python_package(arch)  # this is the same as in a PythonRecipe

    def install_python_package(self, arch, name=None, env=None, is_dir=True):
        """Automate the installation of a Python package (or a cython
        package where the cython components are pre-built)."""
        # arch = self.filtered_archs[0]  # old kivy-ios way
        if name is None:
            name = self.name
        if env is None:
            env = self.get_recipe_env(arch)

        info("Installing {} into site-packages".format(self.name))

        build_dir = self.get_build_dir(arch.arch)
        source_dir = join(build_dir, "grpc")
        with current_directory(source_dir):
            hostpython = sh.Command(self.hostpython_location)

            if self.ctx.python_recipe.name != "python2legacy":
                hpenv = env.copy()
                shprint(
                    hostpython,
                    "setup.py",
                    "install",
                    "-O2",
                    "--root={}".format(self.ctx.get_python_install_dir()),
                    "--install-lib=.",
                    _env=hpenv,
                    *self.setup_extra_args
                )
            elif self.call_hostpython_via_targetpython:
                shprint(
                    hostpython,
                    "setup.py",
                    "install",
                    "-O2",
                    _env=env,
                    *self.setup_extra_args
                )
            else:  # python2legacy
                hppath = join(dirname(self.hostpython_location), "Lib", "site-packages")
                hpenv = env.copy()
                if "PYTHONPATH" in hpenv:
                    hpenv["PYTHONPATH"] = ":".join(
                        [hppath] + hpenv["PYTHONPATH"].split(":")
                    )
                else:
                    hpenv["PYTHONPATH"] = hppath
                shprint(
                    hostpython,
                    "setup.py",
                    "install",
                    "-O2",
                    "--root={}".format(self.ctx.get_python_install_dir()),
                    "--install-lib=lib/python2.7/site-packages",
                    _env=hpenv,
                    *self.setup_extra_args
                )

            # If asked, also install in the hostpython build dir
            if self.install_in_hostpython:
                self.install_hostpython_package(arch)

    def build_cython_components(self, arch):
        env = self.get_recipe_env(arch)
        build_dir = self.get_build_dir(arch.arch)
        source_dir = join(build_dir, "grpc")
        with current_directory(source_dir):
            hostpython = sh.Command(self.ctx.hostpython)

            info("{}".format(env))
            info("{}".format("TEST"))

            # ...so we manually run cython from the user's system
            shprint(
                sh.find,
                join(source_dir, self.cython_args[0]),
                "-iname",
                "*.pyx",
                "-exec",
                self.ctx.cython,
                "--cplus",
                "{}",
                ";",
                _env=env,
            )

            # now cython has already been run so the build works
            try:
                shprint(hostpython, "setup.py", "build_ext", "-v", _env=env)
            except sh.ErrorReturnCode as e:
                for line in str(e.stdout).split("\\n"):
                    print(line)
                return

            # stripping debug symbols lowers the file size a lot
            build_lib = glob.glob("./build/lib*")
            info("{}".format(build_lib))
            shprint(
                sh.find,
                "./build/",
                "-name",
                "*.o",
                "-exec",
                env["STRIP"],
                "{}",
                ";",
                _env=env,
            )


recipe = GRPCRecipe()
